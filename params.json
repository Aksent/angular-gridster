{"name":"Angular-gridster","tagline":"An implementation of gidster-like widgets for Angular JS","body":"angular-gridster\r\n================\r\n\r\nAn implementation of gridster-like widgets for Angular JS.  This is not a wrapper on the original gridster jQuery plugin (http://gridster.net/).  It is instead completely rewritten as Angular directives.  Rewriting allowed for some additional features and better use of Angular data binding.  Even more importantly, the original plugin had unpredictable behavior and crashed when wrapped with an Angular directive in my initial tests.\r\n\r\nDemo html/css/js is included and can be executed by running \"grunt serve\" or by opening app/index.html in a web browser.\r\n\r\nHere is an example of the default usage:\r\n```HTML\r\n    <div gridster>\r\n    \t<ul>\r\n    \t\t<li gridster-item=\"item\" ng-repeat=\"item in standardItems\"></li>\r\n    \t</ul>\r\n    </div>\r\n```\r\nWhich expects a scope setup like the following:\r\n``` JavaScript\r\n    // IMPORTANT: Items should be placed in the grid in the order in which they should appear.\r\n    // In most cases the sorting should be by row ASC, col ASC\r\n\r\n    // these map directly to gridsterItem directive options\r\n    $scope.standardItems = [\r\n      { sizeX: 2, sizeY: 1, row: 0, col: 0 },\r\n      { sizeX: 2, sizeY: 2, row: 0, col: 2 },\r\n      { sizeX: 1, sizeY: 1, row: 0, col: 4 },\r\n      { sizeX: 1, sizeY: 1, row: 0, col: 5 },\r\n      { sizeX: 2, sizeY: 1, row: 1, col: 0 },\r\n      { sizeX: 1, sizeY: 1, row: 1, col: 4 },\r\n      { sizeX: 1, sizeY: 2, row: 1, col: 5 },\r\n      { sizeX: 1, sizeY: 1, row: 2, col: 0 },\r\n      { sizeX: 2, sizeY: 1, row: 2, col: 1 },\r\n      { sizeX: 1, sizeY: 1, row: 2, col: 3 },\r\n      { sizeX: 1, sizeY: 1, row: 2, col: 4 }\r\n    ];\r\n```\r\nAlternatively, you can use the html attributes, similar to the original gridster plugin, but with two-way data binding:\r\n```HTML\r\n    <div gridster>\r\n    \t<ul>\r\n    \t\t<li gridster-item row=\"item.position[0]\" col=\"item.position[1]\" size-x=\"item.size.x\" size-y=\"item.size.y\" ng-repeat=\"item in customItems\"></li>\r\n    \t</ul>\r\n    </div>\r\n```\r\nor:\r\n```HTML\r\n    <div data-gridster>\r\n    \t<ul>\r\n    \t\t<li data-gridster-item data-row=\"item.position[0]\" data-col=\"item.position[1]\" data-sizex=\"item.size.x\" data-sizey=\"item.size.y\" ng-repeat=\"item in customItems\"></li>\r\n    \t</ul>\r\n    </div>\r\n```\r\nThis allows the items to provide their own structure for row, col, and size:\r\n```JavaScript\r\n    $scope.customItems = [\r\n      { size: { x: 2, y: 1 }, position: [0, 0] },\r\n      { size: { x: 2, y: 2 }, position: [0, 2] },\r\n      { size: { x: 1, y: 1 }, position: [0, 4] },\r\n      { size: { x: 1, y: 1 }, position: [0, 5] },\r\n      { size: { x: 2, y: 1 }, position: [1, 0] },\r\n      { size: { x: 1, y: 1 }, position: [1, 4] },\r\n      { size: { x: 1, y: 2 }, position: [1, 5] },\r\n      { size: { x: 1, y: 1 }, position: [2, 0] },\r\n      { size: { x: 2, y: 1 }, position: [2, 1] },\r\n      { size: { x: 1, y: 1 }, position: [2, 3] },\r\n      { size: { x: 1, y: 1 }, position: [2, 4] }\r\n    ];\r\n```\r\nInstead of using attributes for row, col, and size, you can also just use a mapping object for the gridster-item directive:\r\n```HTML\r\n    <div gridster=\"gridsterOpts\">\r\n    \t<ul>\r\n    \t\t<li gridster-item=\"customItemMap\" ng-repeat=\"item in customItems\"></li>\r\n    \t</ul>\r\n    </div>\r\n```\r\nThis expects a scope similar to the previous example, but with customItemMap also defined in the scope:\r\n```JavaScript\r\n    // maps the item from customItems in the scope to the gridsterItem options\r\n    $scope.customItemMap = {\r\n        sizeX: 'item.size.x',\r\n        sizeY: 'item.size.y',\r\n        row: 'item.position[0]',\r\n        col: 'item.position[1]'\r\n    };\r\n```\r\nThe gridsterItem directive can be configured like this:\r\n```HTML\r\n    <div gridster=\"gridsterOpts\">\r\n        <ul>\r\n            <li gridster-item=\"item\" ng-repeat=\"item in standardItems\"></li>\r\n        </ul>\r\n    </div>\r\n```\r\nWith a scope like:\r\n```JavaScript\r\n    $scope.gridsterOpts = {\r\n      minRows: 2, // the minimum height of the grid, in rows\r\n      maxRows: 100,\r\n      columns: 6, // the width of the grid, in columns\r\n      colWidth: 'auto', // can be an integer or 'auto'.  'auto' uses the pixel width of the element divided by 'columns'\r\n      rowHeight: 'match', // can be an integer or 'match'.  Match uses the colWidth, giving you square widgets.\r\n      margins: [10, 10], // the pixel distance between each widget\r\n      defaultSizeX: 2, // the default width of a gridster item, if not specifed\r\n      defaultSizeY: 1, // the default height of a gridster item, if not specified\r\n      mobileBreakPoint: 600, // if the screen is not wider that this, remove the grid layout and stack the items\r\n      resize: {\r\n         enabled: true,\r\n         start: function(event, uiWidget, $element) {}, // optional callback fired when resize is started,\r\n         resize: function(event, uiWidget, $element) {}, // optional callback fired when item is resized,\r\n         stop: function(event, uiWidget, $element) {} // optional callback fired when item is finished resizing\r\n      },\r\n      draggable: {\r\n         enabled: true, // whether dragging items is supported\r\n         handle: '.my-class', // optional selector for resize handle\r\n         start: function(event, uiWidget, $element) {}, // optional callback fired when drag is started,\r\n         drag: function(event, uiWidget, $element) {}, // optional callback fired when item is moved,\r\n         stop: function(event, uiWidget, $element) {} // optional callback fired when item is finished dragging\r\n      }\r\n    };\r\n```\r\nThis directive/plugin does not generate style tags, like the jQuery plugin.  It also uses standard camalCase for variables and object properties, while the original plugin used lower\\_case\\_with_underscores.  These options have not and may never be implemented:\r\n\r\n* widget_class - not necessary since directives already whatever classes and attributes you want to add\r\n* widget_margins - replaced by 'margins'\r\n* widget\\_base\\_dimensions - replaced by 'defaultSizeX' and 'defaultSizeY'\r\n* min_cols - currently, only 'columns' is used to defined the maximum width\r\n* max_cols - currently, only 'columns' is used to defined the maximum width\r\n* min_rows - replaced by 'minRows'\r\n* max_rows - replaced by 'maxRows'\r\n* max\\_size\\_x\r\n* max\\_size\\_y\r\n* extra_cols\r\n* extra_rows\r\n* autogenerate_stylesheet\r\n* avoid\\_overlapped\\_widgets\r\n* resize.axes\r\n* resize.handle_class - replaced by 'resize.handle', which doesn't need to be a class\r\n* resize.handle\\_append\\_to\r\n* resize.max_size\r\n* collision.on\\_overlap\\_start\r\n* collision.on_overlap\r\n* collision.on\\_overlap\\_stop\r\n\r\n\r\nWatching item size and position:\r\n\r\nThe typical Angular way would be to do a $scope.$watch on your item or items in the scope.  Example:\r\n\r\n```JavaScript\r\n// two objects, converted to gridster items in the view via ng-repeat\r\n$scope.items = [{},{}];\r\n\r\n$scope.$watch('items', function(items){\r\n   // one of the items changed\r\n}, true);\r\n```\r\n\r\nor\r\n\r\n```JavaScript\r\n$scope.watch('items[0]', function(){\r\n   // item0 changed\r\n}, true);\r\n```\r\n\r\nor\r\n\r\n```JavaScript\r\n$scope.watch('items[0].sizeX', function(){\r\n   // item0 sizeX changed\r\n}, true);\r\n```\r\n\r\nThe third argument, true, is to make the watch based on the value of the object, rather than just matching the reference to the object.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}